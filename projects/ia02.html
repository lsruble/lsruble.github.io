<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Name - robruble</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet">
    <style>
        .project-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
        }
        .project-info div {
            flex: 1;
        }
        .project-description img {
            max-width: 100%;
            height: auto;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <header>
        <h1>Monte Carlo Tree Search for Gopher</h1>
        <nav style="display: flex; gap: 20px;">
            <a href="../index.html">Home</a>
            <a href="../projects.html">Projects</a>
        </nav>
    </header>
    <main>
        <section class="project-info">
            <div>
                <h2>Duration</h2>
                <p>February 2024 - July 2024</p>
            </div>
            <div>
                <h2>Location</h2>
                <p>Université de Technologie de Compiègne</p>
            </div>
        </section>
        <section class="project-description">
            <h2>Description</h2>

  <p>Gopher is a strategy game where two players compete on a grid, aiming to capture as many cells as possible. Players move in four directions (up, down, left, right) to control territory while trying to block their opponent’s moves. The goal is to capture the most cells and restrict the opponent's movement.
    In this project, I developed a <strong>Monte Carlo Tree Search (MCTS)</strong> strategy for the Gopher game. The algorithm was built from scratch and incorporates dynamic simulations, filtering of non-promising moves, and reusing evaluations of previously explored positions.</p>
  <figure>
    <img src="images/gopher2.gif" alt="MCTS Algorithm Visualization" style="width:100%; max-width:600px;">
  </figure>
  <h3>Key Features</h3>
  <ul>
    <li><strong>Dynamic Simulations:</strong> The number of simulations increases as the game progresses to explore more deeply in later stages. This is controlled by the formula: 
      <code>nb_simulations = 1 + int(80 * calculer_prop_plateau(grid))</code></li>
    <li><strong>Move Filtering:</strong> Only "promising" moves are explored to reduce unnecessary simulations and focus on potential winning strategies.</li>
    <li><strong>Reusing Previous Evaluations:</strong> A dictionary stores cumulative scores and the number of simulations, avoiding recalculating known positions.</li>
    <li><strong>Early Simulation Termination:</strong> Simulations stop if a clearly bad move is detected, saving computation time.</li>
    <li><strong>Upper Confidence Bound (UCT) Formula:</strong> The algorithm balances exploration and exploitation using the UCT formula with an exploration coefficient of sqrt(2).</li>
  </ul>

  <h3>Results</h3>
  <p>The algorithm achieved <strong>2 wins and 2 losses</strong> in a tournament. Key areas for improvement include time management, opening strategies, and better resource allocation in simulations.</p>

  <h3>Future Improvements</h3>
  <ul>
    <li>Optimize for different time constraints (e.g., 10s, 1min).</li>
    <li>Refine the opening strategy to avoid quick defeats.</li>
    <li>Implement logarithmic growth for simulations to enhance performance.</li>
  </ul>

  <h3>Resources</h3>
  <p>Course materials from IA02 and Gopher Ludii AI were used during development.</p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 robruble</p>
    </footer>
</body>
</html>
